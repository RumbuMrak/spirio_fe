import { UserType } from "@/features/user/types/user";import { cn,  serializeJsonToFormData } from "@/services/utils";import router from "next/router";import { useEffect, useMemo, useRef, useState } from "react";import {    Channel, ChannelList,    ChannelPreviewUIComponentProps, Chat, MessageInput, MessageInputProps, MessageList, Streami18n, useChannelStateContext,    useChatContext, useCreateChatClient, Window} from "stream-chat-react";import 'stream-chat-react/dist/css/v2/index.css';import { addUserToChannel, connectUser, setToken, createChannel } from "../chat.actions";import s from '@/features/chat/components/chat.module.css';import { toast } from "@/components/UI/Toast";import translations from './i18n/cs.json';import { Chat as ChatIcon } from '@phosphor-icons/react';import Spinner from "@/components/UI/spinner/Spinner";import api from "@/services/api";import Routes from "@/services/routes";import { IconGlobe } from "@/components/UI/Icons";import { updateGuideStatus } from "@/features/user/modules/user";const streami18n = new Streami18n({    language: "cs",});const streamApiKey = process.env.NEXT_PUBLIC_STREAM_API_KEY!;const StreamChat: (props: {    userData: UserType;    chatId: string;    token: string;    onRevalidate: () => Promise<UserType>;}) => JSX.Element | null = ({ userData, chatId, token, onRevalidate }) => {    const [ready, setReady] = useState(false)    const [channel, setChannel] = useState<any>();    const userId = chatId.split('-')[1];    const guideId = chatId.split('-')[2];    const [notification5minShowed, setNotification5minShowed] = useState(false);    const [notification2minShowed, setNotification2minShowed] = useState(false);    const internalchatId = router.query.chatid as string;    const client = useCreateChatClient({        apiKey: streamApiKey,        tokenOrProvider: token,        userData: { id: userData.id, name: userData?.email, image: userData?.avatar },    });    useEffect(() => {        const initTranslation = async () => {            await streami18n.init();            await streami18n.registerTranslation('cs', translations);        };        initTranslation();    }, [userData]);    useEffect(() => {        if (client && userData?.id) {            fetchUserData();        }    }, [client, userData?.id]);    useEffect(() => {        if (notification5minShowed) {            toast.info('Zbývá méně než 5 minut.', { duration: 10000 });        }        if (notification2minShowed) {            toast.info('Zbývá méně než 2 minuty.', { duration: 10000 });        }    }, [notification5minShowed, notification2minShowed]);    const revalidateIntervalRef = useRef<NodeJS.Timeout | null>(null);    useEffect(() => {        if ( (userData.role === 'customer' || userData.role === 'host')) {            revalidateIntervalRef.current = setInterval(async () => {                const updatedUser = await onRevalidate();                if (updatedUser && updatedUser?.seconds_balance <= 300 && !notification5minShowed) {                    setNotification5minShowed(true);                }                if (updatedUser && updatedUser?.seconds_balance <= 120 && !notification2minShowed) {                    setNotification2minShowed(true);                }                if (updatedUser && updatedUser?.seconds_balance <= 0) {                    clearInterval(revalidateIntervalRef.current!);                    await api.post(                        "/chat/update",                        serializeJsonToFormData({ id: internalchatId, has_ended: true })                    );                    const ch = client?.channel("messaging", chatId);                    await ch?.delete();                    toast.error("Nemáte dostatek kreditů.");                    router.push(Routes["subscriptions"]);                }            }, 3000);        }        return () => clearInterval(revalidateIntervalRef.current!);    }, [userData?.id, channel]);    const fetchUserData = async () => {        if (!userData) {            return null;        }        if (channel) return;        setToken(token, userData.id);        await connectUser(userData, token);        try {            await connectUser(userData, token);            if ( (userData.role === 'customer' || userData.role === 'host')) {                const channel = await createChannel({                    userId: userData.id,                    data: {                        name: 'Komunikace s pruvodcem',                        imageUrl: '',                    },                    channelId: chatId,                });                setChannel(channel.channel);            }        } catch (err) {            console.error("Error initializing chat:", err);            toast.error("Chyba při připojování k chatu.");        }        const { success } = await addUserToChannel(chatId, userData.id, guideId);        if (success) {            setReady(true);            if (userData?.role === 'guide') {                updateGuideStatus('busy');            };            const createdCall = await api.post(                '/chat/store',                serializeJsonToFormData({                    getstream_call_id: chatId,                    getstream_chat_id: chatId,                    user_id: userId,                    guide_profile_id: guideId,                }),            );            const createdCallId = createdCall.data.data.id;            router.replace({ pathname: Routes['chat'], query: { ...router.query, chatid: createdCallId } });        } else {        }    }    const filters = { members: { $in: [userData?.id ?? ''] }, type: "messaging" };    const options = { presence: true, state: true };    if (!client) return (        <ConfirmMember />    );    if (!client || !ready) return <ConfirmMember />;    return (        <Chat client={client} i18nInstance={streami18n}>            <div className={cn(s.cc, s.wrapper)}>                <div className={cn(s.cl, "xl:block hidden")}>                    <ChannelList                        sort={{ last_message_at: -1 }}                        filters={filters}                        options={options}                        Preview={CustomChannelListItem}                    />                </div>                <div className={s.cp}>                    <Channel channel={channel}>                        <Window>                            <CustomChannelHeader userData={userData} chatId={chatId} />                            <MessageList />                            {userData.role === 'guide' ? (                                <SpirioMessageInput  />                            ) : (                                <MessageInput />                            )}                        </Window>                    </Channel>                </div>            </div>        </Chat>    );}type SpirioMessageInputProps = MessageInputProps & {    onVykladClick?: (active: boolean) => void;  };  const SpirioMessageInput: React.FC<SpirioMessageInputProps> = ({    onVykladClick,    ...props  }) => {    const { channel } = useChannelStateContext();    const { client } = useChatContext();    const [vykladActive, setVykladActive] = useState(false);    const handleVykladClick = async () => {      if (!channel) return;      const newState = !vykladActive;      setVykladActive(newState);      await channel.sendMessage({        text: newState          ? 'Průvodce právě vykládá..'          : 'Průvodce přestal vykládat.',      });      if (onVykladClick) onVykladClick(newState);    };    useEffect(() => {      if (!channel || !client?.user?.id) return;      const listener = (event: any) => {        const fromCurrentUser = event.user?.id === client.user?.id;        const isToggleMessage =          event.message?.text === 'Průvodce právě vykládá..' ||          event.message?.text === 'Průvodce přestal vykládat.';        if (fromCurrentUser && vykladActive && !isToggleMessage) {          setVykladActive(false);          if (onVykladClick) onVykladClick(false);        }      };      channel.on('message.new', listener);      return () => channel.off('message.new', listener);    }, [channel, client, vykladActive, onVykladClick]);    return (      <div className="custom-message-input-wrapper bg-primary-750 flex gap-5 items-center">        <button          onClick={handleVykladClick}          className={`flex flex-row items-center rounded-md h-10 w-27 ml-3 ${            vykladActive              ? 'bg-yellow-500 hover:bg-yellow-400'              : 'bg-primary-700 hover:bg-primary-500'          }`}        >          <IconGlobe className="w-10 h-10" />          <span className="ml-2 mr-5">            {vykladActive ? 'Zastavit výklad' : 'Výklad'}          </span>        </button>        <MessageInput {...props} />      </div>    );  };function ConfirmMember() {    return (        <div className='flex flex-col items-center justify-center h-screen'>            <h1 className='text-2xl font-bold mb-4 text-blue-500'>                Počkejte na připojení            </h1>            <p className='text-lg mb-4'>                Připojení se navazuje, prosím chvilku strpení            </p>            <div className='loader'>                <Spinner color="white" className="!h-12 !w-12" />            </div>        </div>    );}const CustomChannelListItem: React.FC<ChannelPreviewUIComponentProps> = ({ channel }) => {    const members = channel.state.members;    const memberNames = Object.values(members).map((member) => member.user?.name);    return (        <div className="str-chat__channel-preview  !bg-primary-775">            <div className="str-chat__channel-preview-inner ">                <div className="str-chat__channel-preview__content ">                    <div className="str-chat__channel-preview__name  flex items-center gap-2">                        <ChatIcon size={55} />                        <div className="flex flex-col">                            <span className="text-xl"> <span className="text-gradient">Chat mezi</span> </span>                            <span >{memberNames.length > 0 && memberNames[0]}  {memberNames.length > 1 && memberNames[1]}</span>                        </div>                    </div>                </div>            </div>        </div>    );};type CustomChannelHeaderProps = {    userData: UserType | null;    chatId: string;};const CustomChannelHeader: React.FC<CustomChannelHeaderProps> = ({ userData, chatId }) => {    const { client } = useChatContext();    const { channel, members } = useChannelStateContext();    const intervalRef = useRef<NodeJS.Timeout | null>(null);    const lastActivityRef = useRef<number>(Date.now());    const [isPaused, setIsPaused] = useState(false);    useEffect(() => {        intervalRef.current = setInterval(() => {            const now = Date.now();            const inactiveFor = now - lastActivityRef.current;            const isInactive = inactiveFor >= 180000;            setIsPaused(isInactive);            const members = channel.data?.member_count ?? 0;            if (                userData?.role === 'guide' &&                !isInactive &&                members > 1 &&                router.query.chatid            ) {                api.post('/chat/update', serializeJsonToFormData({                    id: router.query.chatid,                    seconds_count: 1                }));            }        }, 2000);        return () => clearInterval(intervalRef.current!);    }, [channel?.data?.member_count, userData?.role]);    useEffect(() => {        const handleMessage = (event: any) => {            lastActivityRef.current = Date.now();            setIsPaused(false);        };        channel?.on('message.new', handleMessage);        return () => {            channel?.off('message.new', handleMessage);        };    }, [channel, client.userID]);    const CallTime = () => {        const [seconds, setSeconds] = useState(0);        useEffect(() => {            const interval = setInterval(() => setSeconds(s => s + 1), 1000);            return () => clearInterval(interval);        }, []);        const minutes = Math.floor(seconds / 60);        const remainingSeconds = seconds % 60;        const formattedTime = `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;        if (userData?.role !== 'customer' && userData?.role !== 'host') return;        return (            <>                <div className="rounded-md px-4 py-2  text-center bg-primary-750 ">Uplynulý čas: {formattedTime}                </div>            </>        );    };    const callTimeComponent = useMemo(() => {        if (channel.data?.member_count === 2) {            if (userData?.role === 'guide') {                updateGuideStatus('busy')            }            return <CallTime />;        }        return null;    }, [channel?.data?.member_count]);    const prevMemberCount = useRef<number | null>(null);    useEffect(() => {        const currentCount = channel?.data?.member_count ?? 0;        if (prevMemberCount.current === 2 && currentCount < 2) {            handleLeave();        }        prevMemberCount.current = currentCount;    }, [channel?.data?.member_count]);    const handleLeave = async () => {        try {            if (!router.query.chatid) return;            const userIds = members                ? Object.values(members)                    .map(x => x.user_id)                    .filter((id): id is string => typeof id === 'string')                : [];            if (userIds.length > 0) {                await channel.removeMembers(userIds);            }            await api.post('/chat/update', serializeJsonToFormData({ id: router.query.chatid, has_ended: true }));            updateGuideStatus('online');            router.push({ pathname: Routes['chat-end'], query: router.query });        } catch (error) {            console.error(error);            toast.error("Chyba pri opusteni kanalu");        }    };    const memberNames = members        ? Object.values(members)            .filter((m) => m.user?.id !== client.userID)            .map((m) => m.user?.name || m.user?.id)            .join(', ')        : '.. čeká se na připojení průvodce';    return (        <div className={s.header}>            <div className={s.left}>                <div className={s.name}>                    Chat s                </div>                <div className={s.members}>                    {memberNames === '' ? '.. čeká se na připojení průvodce' : memberNames}                </div>            </div>            <>                {isPaused ? (                    <div className="rounded-md px-4 py-2 mt-2 text-yellow-600 bg-yellow-100 text-sm">                        Časovač je pozastaven kvůli neaktivitě                    </div>                ) : (                    callTimeComponent                )}            </>            <button className={s.leaveButton} onClick={handleLeave}>                Opustit            </button>        </div>    );};export const useLastMessageTimeout = ({    timeoutMs = 60000,    onTimeout,    onMessageSent,}: {    timeoutMs?: number;    onTimeout: () => void;    onMessageSent: (userid: string) => void;}) => {    const { client } = useChatContext();    const { channel } = useChannelStateContext();    const [lastSent, setLastSent] = useState<number | null>(null);    useEffect(() => {        const handleMessageSent = (event: any) => {            if (event.user?.id === client.userID) {                setLastSent(Date.now());                onMessageSent?.(client.userID ?? '');            }        };        channel?.on('message.new', handleMessageSent);        return () => {            channel?.off('message.new', handleMessageSent);        };    }, [channel, client.userID]);    useEffect(() => {        if (!lastSent) return;        const timeout = setTimeout(() => {            const diff = Date.now() - lastSent;            if (diff >= timeoutMs) {                onTimeout?.();            }        }, timeoutMs);        return () => clearTimeout(timeout);    }, [lastSent, timeoutMs, onTimeout]);};export default StreamChat;